# -*- coding: utf-8 -*-
"""Extract.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PmtfrqyRAiN87_m-mkPkWSB2-OCvfVQk
"""

!pip -q install pdfplumber pandas numpy openpyxl

from google.colab import files
uploaded = files.upload()  # select ALL PDFs together

import re
import numpy as np
import pandas as pd
import pdfplumber
import logging
from google.colab import files

logging.getLogger("pdfminer").setLevel(logging.ERROR)

def clean_number(s):
    if s is None:
        return np.nan
    s = str(s).strip()
    if s == "":
        return np.nan
    s = s.replace("$", "").replace(",", "")
    if s.startswith("(") and s.endswith(")"):
        s = "-" + s[1:-1]
    try:
        return float(s)
    except:
        return np.nan

def extract_text(pdf_path):
    parts = []
    with pdfplumber.open(pdf_path) as pdf:
        for p in pdf.pages:
            t = p.extract_text()
            if t:
                parts.append(t)
    return "\n".join(parts)

def first_match(text, patterns):
    for pat in patterns:
        m = re.search(pat, text, flags=re.IGNORECASE | re.DOTALL)
        if m:
            return m.group(1)
    return None

def extract_apple_revenue(text):
    matches = re.findall(
        r"Total\s+net\s+sales\s+\$?\s*([\d,]+)\s+\$?\s*([\d,]+)\s+\$?\s*([\d,]+)",
        text,
        flags=re.IGNORECASE
    )
    if matches:
        return matches[0][0]  # latest fiscal year revenue
    return None

def extract_apple_metrics_from_pdf(pdf_path):
    text = extract_text(pdf_path)

    revenue = extract_apple_revenue(text)

    net_income = first_match(text, [
        r"Net\s+income\s+\$?\s*([\(\)\d,\.]+)"
    ])

    total_assets = first_match(text, [
        r"Total\s+assets\s+\$?\s*([\(\)\d,\.]+)"
    ])

    total_liabilities = first_match(text, [
        r"Total\s+liabilities\s+\$?\s*([\(\)\d,\.]+)"
    ])

    cfo = first_match(text, [
        r"Cash\s+generated\s+by\s+operating\s+activities\s+([\(\)\d,\.]+)",
        r"Net\s+cash\s+provided\s+by\s+operating\s+activities\s+([\(\)\d,\.]+)"
    ])

    return {
        "Total Revenue (USD millions)": clean_number(revenue),
        "Net Income (USD millions)": clean_number(net_income),
        "Total Assets (USD millions)": clean_number(total_assets),
        "Total Liabilities (USD millions)": clean_number(total_liabilities),
        "Operating Cash Flow (USD millions)": clean_number(cfo),
    }

# ---- Run for app2023/app2024/app2025 ----
rows = []
for fn in sorted(uploaded.keys(), key=lambda x: x.lower()):
    if fn.lower().startswith("app") and fn.lower().endswith(".pdf"):
        year_match = re.search(r"(20\d{2})", fn)
        fy = int(year_match.group(1)) if year_match else None

        metrics = extract_apple_metrics_from_pdf(fn)
        metrics["Company"] = "Apple"
        metrics["Fiscal Year (filename)"] = fy
        metrics["File"] = fn
        rows.append(metrics)

df = pd.DataFrame(rows).sort_values("Fiscal Year (filename)").reset_index(drop=True)

print("APPLE FINAL EXTRACTED TABLE:")
display(df)

combined_df = pd.concat([df, df_all]).reset_index(drop=True)
print("COMBINED TABLE:")
display(combined_df)

from google.colab import files
uploaded = files.upload()  # select ALL PDFs together

# =========================
# COMBINED FINAL CODE (Apple + Microsoft + Tesla)
# Works with your uploaded filenames:
#   app2023.pdf app2024.pdf app2025.pdf
#   Micro 2023.pdf Micro 2024.pdf Micro2025.pdf
#   tsla2023.pdf tsla2024.pdf tsla2025.pdf
#
# Extracts 5 fields for each PDF (latest fiscal-year column in that filing):
#   Total Revenue, Net Income, Total Assets, Total Liabilities, Operating Cash Flow (CFO)
#
# NOTE: Run this AFTER you already did:
#   from google.colab import files
#   uploaded = files.upload()
# =========================

import re
import numpy as np
import pandas as pd
import pdfplumber
import logging
from google.colab import files

logging.getLogger("pdfminer").setLevel(logging.ERROR)

# ---------- Helpers ----------
def clean_number(s):
    if s is None:
        return np.nan
    s = str(s).strip().replace("$", "").replace(",", "")
    if s.startswith("(") and s.endswith(")"):
        s = "-" + s[1:-1]
    try:
        return float(s)
    except:
        return np.nan

def extract_text(pdf_path):
    parts = []
    with pdfplumber.open(pdf_path) as pdf:
        for p in pdf.pages:
            t = p.extract_text()
            if t:
                parts.append(t)
    return "\n".join(parts)

def parse_year_from_filename(filename):
    m = re.search(r"(20\d{2})", filename)
    return int(m.group(1)) if m else None

def norm_name(filename):
    return filename.lower().replace(" ", "")

def pick3_firstcol(text, patterns):
    """
    Find a 3-year row and return the FIRST number (latest fiscal year column in that 10-K).
    patterns should capture 3 numbers OR match 'label <num> <num> <num>' and capture first <num>.
    """
    for pat in patterns:
        m = re.search(pat, text, flags=re.IGNORECASE)
        if m:
            return m.group(1)
    return None

def pick2_firstcol(text, patterns):
    """Fallback: 2-year row (balance sheet often 2 years). Return first number."""
    for pat in patterns:
        m = re.search(pat, text, flags=re.IGNORECASE)
        if m:
            return m.group(1)
    return None


# ==========================================================
# APPLE extractors (Revenue is "Total net sales")
# ==========================================================
def apple_revenue(text):
    return pick3_firstcol(text, [
        r"Total\s+net\s+sales\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+"
    ])

def apple_net_income(text):
    return pick3_firstcol(text, [
        r"Net\s+income\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+"
    ])

def apple_assets(text):
    # Apple balance sheet is usually 2 years
    v = pick2_firstcol(text, [
        r"Total\s+assets\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+"
    ])
    if v is None:
        v = pick3_firstcol(text, [
            r"Total\s+assets\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+"
        ])
    return v

def apple_liabilities(text):
    v = pick2_firstcol(text, [
        r"Total\s+liabilities\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+"
    ])
    if v is None:
        v = pick3_firstcol(text, [
            r"Total\s+liabilities\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+"
        ])
    return v

def apple_cfo(text):
    return pick3_firstcol(text, [
        r"Cash\s+generated\s+by\s+operating\s+activities\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
        r"Net\s+cash\s+provided\s+by\s+operating\s+activities\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
    ])

def extract_apple(pdf_path):
    text = extract_text(pdf_path)
    return {
        "Total Revenue (USD millions)": clean_number(apple_revenue(text)),
        "Net Income (USD millions)": clean_number(apple_net_income(text)),
        "Total Assets (USD millions)": clean_number(apple_assets(text)),
        "Total Liabilities (USD millions)": clean_number(apple_liabilities(text)),
        "Operating Cash Flow (USD millions)": clean_number(apple_cfo(text)),
    }


# ==========================================================
# MICROSOFT extractors (Revenue row often "Revenue")
# ==========================================================
def msft_revenue(text):
    return pick3_firstcol(text, [
        r"\bRevenue\b\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
        r"\bTotal\s+revenue\b\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
    ])

def msft_net_income(text):
    return pick3_firstcol(text, [
        r"\bNet\s+income\b\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
        r"\bNet\s+income\s*\(loss\)\b\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
    ])

def msft_assets(text):
    v = pick3_firstcol(text, [
        r"\bTotal\s+assets\b\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+"
    ])
    if v is None:
        v = pick2_firstcol(text, [
            r"\bTotal\s+assets\b\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+"
        ])
    return v

def msft_liabilities(text):
    v = pick3_firstcol(text, [
        r"\bTotal\s+liabilities\b\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+"
    ])
    if v is None:
        v = pick2_firstcol(text, [
            r"\bTotal\s+liabilities\b\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+"
        ])
    return v

def msft_cfo(text):
    return pick3_firstcol(text, [
        r"Net\s+cash\s+from\s+operations\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
        r"Net\s+cash\s+from\s+operating\s+activities\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
        r"Net\s+cash\s+provided\s+by\s+operating\s+activities\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
    ])

def extract_msft(pdf_path):
    text = extract_text(pdf_path)
    return {
        "Total Revenue (USD millions)": clean_number(msft_revenue(text)),
        "Net Income (USD millions)": clean_number(msft_net_income(text)),
        "Total Assets (USD millions)": clean_number(msft_assets(text)),
        "Total Liabilities (USD millions)": clean_number(msft_liabilities(text)),
        "Operating Cash Flow (USD millions)": clean_number(msft_cfo(text)),
    }


# ==========================================================
# TESLA extractors (Revenue row often "Total revenues" or "Revenues")
# ==========================================================
def tsla_revenue(text):
    return pick3_firstcol(text, [
        r"Total\s+revenues?\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
        r"\bRevenues?\b\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
    ])

def tsla_net_income(text):
    return pick3_firstcol(text, [
        r"Net\s+income\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
        r"Net\s+income\s*\(loss\)\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
    ])

def tsla_assets(text):
    v = pick2_firstcol(text, [
        r"Total\s+assets\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+"
    ])
    if v is None:
        v = pick3_firstcol(text, [
            r"Total\s+assets\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+"
        ])
    return v

def tsla_liabilities(text):
    v = pick2_firstcol(text, [
        r"Total\s+liabilities\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+"
    ])
    if v is None:
        v = pick3_firstcol(text, [
            r"Total\s+liabilities\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+"
        ])
    return v

def tsla_cfo(text):
    return pick3_firstcol(text, [
        r"Net\s+cash\s+provided\s+by\s+operating\s+activities\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
        r"Net\s+cash\s+from\s+operating\s+activities\s+\$?\s*([\d,]+)\s+\$?\s*[\d,]+\s+\$?\s*[\d,]+",
    ])

def extract_tsla(pdf_path):
    text = extract_text(pdf_path)
    return {
        "Total Revenue (USD millions)": clean_number(tsla_revenue(text)),
        "Net Income (USD millions)": clean_number(tsla_net_income(text)),
        "Total Assets (USD millions)": clean_number(tsla_assets(text)),
        "Total Liabilities (USD millions)": clean_number(tsla_liabilities(text)),
        "Operating Cash Flow (USD millions)": clean_number(tsla_cfo(text)),
    }


# ==========================================================
# Router: detect company by filename
# ==========================================================
def detect_company(filename):
    n = norm_name(filename)
    if n.startswith("app") or "apple" in n:
        return "Apple"
    if "micro" in n or "msft" in n or "microsoft" in n:
        return "Microsoft"
    if "tsla" in n or "tesla" in n:
        return "Tesla"
    return "Unknown"


# ==========================================================
# Run extraction 1-by-1 + combined output
# ==========================================================
rows = []
file_list = sorted(list(uploaded.keys()), key=lambda x: x.lower())

for fn in file_list:
    company = detect_company(fn)
    fy_file = parse_year_from_filename(fn)

    if company == "Unknown" or not fn.lower().endswith(".pdf"):
        continue

    print("\n" + "="*95)
    print(f"FILE: {fn}")
    print(f"Company: {company} | Year(from filename): {fy_file}")
    print("-"*95)

    if company == "Apple":
        metrics = extract_apple(fn)
    elif company == "Microsoft":
        metrics = extract_msft(fn)
    else:  # Tesla
        metrics = extract_tsla(fn)

    # Print one-by-one
    for k, v in metrics.items():
        print(f"{k:35} -> {v}")

    rows.append({
        "Company": company,
        "Fiscal Year (filename)": fy_file,
        "File": fn,
        **metrics
    })

df_all = pd.DataFrame(rows).sort_values(["Company", "Fiscal Year (filename)"]).reset_index(drop=True)

print("\n" + "="*95)
print("FINAL COMBINED TABLE:")
display(df_all)

final_df = pd.concat([df, df_all], ignore_index=True)
final_df

final_df = final_df.sort_values(["Company","Fiscal Year (filename)"]).reset_index(drop=True)
final_df

final_df.to_csv("FINAL_FINANCIAL_DATASET.csv", index=False)

import pandas as pd
import numpy as np

# Load your CSV
df = pd.read_csv("FINAL_FINANCIAL_DATASET.csv")

# Standardize column names (edit if your names differ)
rename_map = {
    "Total Revenue (USD millions)": "Total Revenue",
    "Net Income (USD millions)": "Net Income",
    "Total Assets (USD millions)": "Total Assets",
    "Total Liabilities (USD millions)": "Total Liabilities",
    "Operating Cash Flow (USD millions)": "CFO",
    "Fiscal Year (filename)": "Year"
}
df = df.rename(columns={k:v for k,v in rename_map.items() if k in df.columns})

# Keep only needed columns (optional)
keep_cols = ["Company","Year","Total Revenue","Net Income","Total Assets","Total Liabilities","CFO"]
df = df[keep_cols].copy()

# Convert to numeric (safe)
num_cols = ["Total Revenue","Net Income","Total Assets","Total Liabilities","CFO"]
for c in num_cols:
    df[c] = pd.to_numeric(df[c], errors="coerce")

# Sort
df = df.sort_values(["Company","Year"]).reset_index(drop=True)

df

for col in ["Total Revenue","Net Income","Total Assets","Total Liabilities","CFO"]:
    df[f"{col} Growth (%)"] = df.groupby("Company")[col].pct_change() * 100

df

df["Liabilities_to_Assets"] = df["Total Liabilities"] / df["Total Assets"]
df["CFO_to_NetIncome"] = df["CFO"] / df["Net Income"]

# Simple flags the chatbot can explain
df["Leverage Flag"] = np.where(df["Liabilities_to_Assets"] > 0.8, "High leverage", "Normal")
df["Cash Quality Flag"] = np.where(df["CFO_to_NetIncome"] < 1.0, "Earnings weaker than cash", "Cash supports earnings")

df[["Company","Year","Liabilities_to_Assets","CFO_to_NetIncome","Leverage Flag","Cash Quality Flag"]]

summary = df.groupby("Company").agg(
    Revenue_CAGR=("Total Revenue", lambda x: (x.iloc[-1]/x.iloc[0])**(1/(len(x)-1))-1 if len(x)>1 else np.nan),
    NetIncome_CAGR=("Net Income", lambda x: (x.iloc[-1]/x.iloc[0])**(1/(len(x)-1))-1 if len(x)>1 else np.nan),
    Avg_Liab_to_Assets=("Liabilities_to_Assets","mean"),
    Avg_CFO_to_NI=("CFO_to_NetIncome","mean")
).reset_index()

summary["Revenue_CAGR (%)"] = summary["Revenue_CAGR"]*100
summary["NetIncome_CAGR (%)"] = summary["NetIncome_CAGR"]*100

summary.drop(columns=["Revenue_CAGR","NetIncome_CAGR"])

import numpy as np
import pandas as pd

def pct(a, b):
    if pd.isna(a) or pd.isna(b) or a == 0:
        return np.nan
    return (b - a) / a * 100

def fmt_money(x):
    if pd.isna(x):
        return "NA"
    # values are in USD millions in your dataset
    return f"{x:,.0f}m"

def fmt_pct(x):
    if pd.isna(x):
        return "NA"
    return f"{x:,.1f}%"

def trend_word(x):
    if pd.isna(x):
        return "unknown"
    if x > 5:
        return "increasing strongly"
    if x > 0:
        return "increasing slightly"
    if x < -5:
        return "declining strongly"
    if x < 0:
        return "declining slightly"
    return "flat"

def generate_summary(df):
    required = ["Company","Year","Total Revenue","Net Income","Total Assets","Total Liabilities","CFO"]
    missing = [c for c in required if c not in df.columns]
    if missing:
        raise ValueError(f"Missing columns: {missing}")

    df2 = df.sort_values(["Company","Year"]).copy()

    # Derived indicators
    df2["Liabilities_to_Assets"] = df2["Total Liabilities"] / df2["Total Assets"]
    df2["CFO_to_NetIncome"] = df2["CFO"] / df2["Net Income"]

    summaries = []
    for company, g in df2.groupby("Company"):
        g = g.sort_values("Year")
        first = g.iloc[0]
        last = g.iloc[-1]

        rev_change = pct(first["Total Revenue"], last["Total Revenue"])
        ni_change  = pct(first["Net Income"], last["Net Income"])
        cfo_change = pct(first["CFO"], last["CFO"])

        lev_first = first["Liabilities_to_Assets"]
        lev_last  = last["Liabilities_to_Assets"]

        cashq_last = last["CFO_to_NetIncome"]

        # Simple interpretations
        leverage_msg = (
            "leverage increased"
            if (not pd.isna(lev_first) and not pd.isna(lev_last) and lev_last > lev_first)
            else "leverage decreased or stayed stable"
        )

        cashq_msg = (
            "cash flow supports earnings"
            if (not pd.isna(cashq_last) and cashq_last >= 1.0)
            else "earnings conversion to cash looks weaker"
        )

        summary_text = (
            f"### {company}\n"
            f"- **Revenue:** {fmt_money(first['Total Revenue'])} → {fmt_money(last['Total Revenue'])} "
            f"({fmt_pct(rev_change)}; {trend_word(rev_change)})\n"
            f"- **Net Income:** {fmt_money(first['Net Income'])} → {fmt_money(last['Net Income'])} "
            f"({fmt_pct(ni_change)}; {trend_word(ni_change)})\n"
            f"- **Operating Cash Flow (CFO):** {fmt_money(first['CFO'])} → {fmt_money(last['CFO'])} "
            f"({fmt_pct(cfo_change)}; {trend_word(cfo_change)})\n"
            f"- **Balance Sheet:** Assets {fmt_money(last['Total Assets'])}, Liabilities {fmt_money(last['Total Liabilities'])}. "
            f"Liabilities/Assets = {lev_last:.2f} ({leverage_msg}).\n"
            f"- **Cash quality (CFO / Net Income):** {cashq_last:.2f} → {cashq_msg}.\n"
        )

        summaries.append({
            "Company": company,
            "Rev_3yr_%": rev_change,
            "NI_3yr_%": ni_change,
            "CFO_3yr_%": cfo_change,
            "Lev_last": lev_last,
            "CashQ_last": cashq_last,
            "Summary": summary_text
        })

    summary_df = pd.DataFrame(summaries)

    # Cross-company highlights
    leader_rev = summary_df.loc[summary_df["Rev_3yr_%"].idxmax(), "Company"] if summary_df["Rev_3yr_%"].notna().any() else "NA"
    leader_ni  = summary_df.loc[summary_df["NI_3yr_%"].idxmax(), "Company"] if summary_df["NI_3yr_%"].notna().any() else "NA"
    best_cashq = summary_df.loc[summary_df["CashQ_last"].idxmax(), "Company"] if summary_df["CashQ_last"].notna().any() else "NA"
    highest_lev= summary_df.loc[summary_df["Lev_last"].idxmax(), "Company"] if summary_df["Lev_last"].notna().any() else "NA"

    cross_text = (
        "## Cross-company highlights\n"
        f"- **Fastest revenue growth (3-year):** {leader_rev}\n"
        f"- **Fastest net income growth (3-year):** {leader_ni}\n"
        f"- **Strongest cash-quality (CFO/NI, latest year):** {best_cashq}\n"
        f"- **Highest leverage (Liabilities/Assets, latest year):** {highest_lev}\n"
        "\n"
        "## Chatbot-ready insight prompts\n"
        "- “Which company’s growth is accelerating vs slowing?”\n"
        "- “Is profit growth aligned with revenue growth?”\n"
        "- “Is leverage rising and does it look risky?”\n"
        "- “Does operating cash flow support reported earnings?”\n"
    )

    return summary_df, cross_text

summary_df, cross_text = generate_summary(df)

# Print the narrative summaries (copy these into a Markdown cell)
for s in summary_df["Summary"]:
    print(s)

print(cross_text)

pip install nbconvert

import re
import pandas as pd
import numpy as np

DATA_PATH = "FINAL_FINANCIAL_DATASET.csv"  # change if needed

# ---- Load + normalize dataset ----
def load_data(path: str) -> pd.DataFrame:
    df = pd.read_csv(path)

    rename_map = {
        "Total Revenue (USD millions)": "Total Revenue",
        "Net Income (USD millions)": "Net Income",
        "Total Assets (USD millions)": "Total Assets",
        "Total Liabilities (USD millions)": "Total Liabilities",
        "Operating Cash Flow (USD millions)": "CFO",
        "Fiscal Year (filename)": "Year",
    }
    df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})

    needed = ["Company", "Year", "Total Revenue", "Net Income", "Total Assets", "Total Liabilities", "CFO"]
    df = df[needed].copy()

    df["Year"] = pd.to_numeric(df["Year"], errors="coerce").astype("Int64")
    for c in ["Total Revenue", "Net Income", "Total Assets", "Total Liabilities", "CFO"]:
        df[c] = pd.to_numeric(df[c], errors="coerce")

    df = df.dropna(subset=["Company", "Year"]).sort_values(["Company", "Year"]).reset_index(drop=True)

    # Derived metrics for insights
    df["Liabilities_to_Assets"] = df["Total Liabilities"] / df["Total Assets"]
    df["Revenue_Growth_%"] = df.groupby("Company")["Total Revenue"].pct_change() * 100
    df["NetIncome_Growth_%"] = df.groupby("Company")["Net Income"].pct_change() * 100
    df["CFO_Growth_%"] = df.groupby("Company")["CFO"].pct_change() * 100
    df["CFO_to_NetIncome"] = df["CFO"] / df["Net Income"]

    return df

def fmt_money_m(x):
    if pd.isna(x):
        return "NA"
    return f"${x:,.0f}m"

def fmt_pct(x):
    if pd.isna(x):
        return "NA"
    return f"{x:,.1f}%"

def latest_year_row(df: pd.DataFrame, company: str) -> pd.Series:
    g = df[df["Company"].str.lower() == company.lower()].sort_values("Year")
    if g.empty:
        return None
    return g.iloc[-1]

def prior_year_row(df: pd.DataFrame, company: str) -> pd.Series:
    g = df[df["Company"].str.lower() == company.lower()].sort_values("Year")
    if len(g) < 2:
        return None
    return g.iloc[-2]

# ---- Simple NLU: detect company + intent from text ----
COMPANY_ALIASES = {
    "apple": ["apple", "aapl", "app"],
    "microsoft": ["microsoft", "msft", "micro"],
    "tesla": ["tesla", "tsla"],
}

def detect_company(text: str):
    t = text.lower()
    for canonical, aliases in COMPANY_ALIASES.items():
        for a in aliases:
            if re.search(rf"\b{re.escape(a)}\b", t):
                return canonical.title() if canonical != "msft" else "Microsoft"
    # canonical mapping
    if "apple" in t or "aapl" in t:
        return "Apple"
    if "microsoft" in t or "msft" in t:
        return "Microsoft"
    if "tesla" in t or "tsla" in t:
        return "Tesla"
    return None

INTENTS = {
    "revenue_latest": [r"\btotal revenue\b", r"\brevenue\b"],
    "net_income_change": [r"\bnet income\b.*\bchange\b", r"\bnet income\b.*\blast year\b", r"\bnet income growth\b"],
    "assets_liabilities_latest": [r"\btotal assets\b", r"\btotal liabilities\b", r"\bbalance sheet\b", r"\bassets and liabilities\b"],
    "cfo_latest": [r"\boperating cash flow\b", r"\bcfo\b", r"\bcash flow from operating\b"],
    "financial_health": [r"\bfinancial health\b", r"\bhealth\b", r"\bleverage\b", r"\bcash quality\b", r"\brisk\b"],
}

def detect_intent(text: str):
    t = text.lower()
    for intent, pats in INTENTS.items():
        for p in pats:
            if re.search(p, t):
                return intent
    return None

# ---- Rule-based response functions ----
def answer_revenue_latest(df, company):
    r = latest_year_row(df, company)
    if r is None:
        return f"I don't have data for {company}. Try Apple, Microsoft, or Tesla."
    return f"{company} total revenue in {int(r['Year'])} is {fmt_money_m(r['Total Revenue'])}."

def answer_net_income_change(df, company):
    r_last = latest_year_row(df, company)
    r_prev = prior_year_row(df, company)
    if r_last is None:
        return f"I don't have data for {company}."
    if r_prev is None:
        return f"I only have one year for {company}, so I can't compute last-year change."
    delta = r_last["Net Income"] - r_prev["Net Income"]
    direction = "increased" if delta >= 0 else "decreased"
    return (
        f"{company} net income {direction} by {fmt_money_m(abs(delta))} from {int(r_prev['Year'])} to {int(r_last['Year'])} "
        f"({fmt_pct(r_last['NetIncome_Growth_%'])})."
    )

def answer_assets_liabilities_latest(df, company):
    r = latest_year_row(df, company)
    if r is None:
        return f"I don't have data for {company}."
    return (
        f"{company} balance sheet in {int(r['Year'])}: "
        f"Total Assets {fmt_money_m(r['Total Assets'])}, Total Liabilities {fmt_money_m(r['Total Liabilities'])}."
    )

def answer_cfo_latest(df, company):
    r = latest_year_row(df, company)
    if r is None:
        return f"I don't have data for {company}."
    return f"{company} cash flow from operating activities (CFO) in {int(r['Year'])} is {fmt_money_m(r['CFO'])}."

def answer_financial_health(df, company):
    r_last = latest_year_row(df, company)
    r_prev = prior_year_row(df, company)
    if r_last is None:
        return f"I don't have data for {company}."

    lev = r_last["Liabilities_to_Assets"]
    cashq = r_last["CFO_to_NetIncome"]

    lev_label = "higher leverage" if (not pd.isna(lev) and lev > 0.8) else "moderate leverage"
    cash_label = "strong cash conversion" if (not pd.isna(cashq) and cashq >= 1.0) else "weaker cash conversion"

    rev_trend = fmt_pct(r_last["Revenue_Growth_%"])
    ni_trend = fmt_pct(r_last["NetIncome_Growth_%"])

    msg = (
        f"{company} financial health (latest year {int(r_last['Year'])}):\n"
        f"- Revenue YoY: {rev_trend}\n"
        f"- Net income YoY: {ni_trend}\n"
        f"- Leverage (Liabilities/Assets): {lev:.2f} → {lev_label}\n"
        f"- Cash quality (CFO/Net income): {cashq:.2f} → {cash_label}\n"
    )

    if r_prev is not None and not pd.isna(r_prev["Liabilities_to_Assets"]) and not pd.isna(lev):
        if lev > r_prev["Liabilities_to_Assets"]:
            msg += "- Note: leverage increased vs prior year.\n"
        else:
            msg += "- Note: leverage decreased or stayed stable vs prior year.\n"

    msg += "Ask: 'total revenue', 'net income change', 'assets and liabilities', 'operating cash flow', or 'financial health'."
    return msg

# ---- Chat loop with simple state ----
RESPONDERS = {
    "revenue_latest": answer_revenue_latest,
    "net_income_change": answer_net_income_change,
    "assets_liabilities_latest": answer_assets_liabilities_latest,
    "cfo_latest": answer_cfo_latest,
    "financial_health": answer_financial_health,
}

HELP_TEXT = """I can answer these predefined queries (include company name):
1) "Apple total revenue"
2) "Microsoft net income change"
3) "Tesla assets and liabilities"
4) "Apple operating cash flow"
5) "Tesla financial health"

Tip: If you mention a company once, you can omit it next time (I’ll remember).
Type 'help' or 'examples' to see this again, or 'exit' to quit.
"""

def run_chatbot():
    df = load_data(DATA_PATH)
    last_company = None

    print("GFC Financial Chatbot (Prototype) ✅")
    print(HELP_TEXT)

    while True:
        user = input("You: ").strip()
        if not user:
            continue
        if user.lower() in ["exit", "quit"]:
            print("Bot: Bye!")
            break
        if user.lower() in ["help", "examples"]:
            print("Bot:", HELP_TEXT)
            continue

        company = detect_company(user) or last_company
        intent = detect_intent(user)

        if company is None:
            print("Bot: Please specify a company (Apple, Microsoft, Tesla). Type 'examples' for prompts.")
            continue

        last_company = company

        if intent is None:
            print("Bot: Sorry — I only support predefined queries. Type 'examples' to see what I can answer.")
            continue

        responder = RESPONDERS[intent]
        print("Bot:", responder(df, company))

if __name__ == "__main__":
    run_chatbot()

"""GFC Financial Chatbot – Prototype (Rule-Based)

How it works:
- Loads FINAL_FINANCIAL_DATASET.csv (Apple, Microsoft, Tesla; 3 years each).
- Uses rule-based intent matching (if/then) for predefined finance queries.
- Remembers last company discussed (basic state management).

Supported queries (examples):
- "Apple total revenue"
- "Microsoft net income change"
- "Tesla assets and liabilities"
- "Apple operating cash flow"
- "Tesla financial health"

Limitations:
- Only predefined intents are supported (no free-form Q&A).
- Metrics depend on the quality of extracted dataset.
- No citation-to-PDF linking in this prototype.

"""

from google.colab import files
files.download("FINAL_FINANCIAL_DATASET.csv")